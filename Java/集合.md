# 集合

## Arrays

Arrays.asList的返回值是Arrays静态内部类ArrayList对象.

## Map

### HashMap

1. HashMap 底层使用数组，数组内存储的对象是Entry，键值对对象。
2. Entry是HashMap内部的静态类，实现Map内部的接口Entry

#### 哈希值

#### 遍历

##### HashMap.keySet()

1. 返回值是Set的实现类KeySet，HashMap中的 private final 类
2. KeySet实现了迭代器接口，迭代器接口返回的迭代器是HashMap内部的KeyIterator。
3. 上一步说的迭代器最终执行的是HashIterator的nextEntry().getKey()方法。

##### HashMap.entrySet()

1. 最终执行的也是HashIterator中的迭代方法。

### TreeMap

1. 底层数据结构是红黑树
2. [红黑树](http://blog.csdn.net/chenhuajie123/article/details/11951777)
3. 使用比较器进行红黑树排序

#### 红黑树条件

1. 每个节点有两种颜色表示，黑或红
2. 根节点颜色为黑色
3. 所有的叶子节点颜色为黑色，在Java中可以考虑集合的叶子节点为NULL，NULL对应为黑色。
4. 如果父节点的颜色为红色，则所有子节点的颜色为黑色。
5. 从根节点到叶子节点经历的节点，黑色节点的数量相同。从根节点开始计算到NULL为止。
6. 红黑树的子数满足除2以外的所有特点。【非正常特点】

#### 插入

1. 空，插入将根节点赋值为插入节点，修改节点颜色为Black
2. 插入节点的父节点颜色为黑，为了满足条件5，将插入节点颜色修改为红色，其他无需修改。
3. 插入节点的父节点颜色为红色，为了满足条件5，将插入节点颜色修改为红色，叶子节点NULL，导致不满足条件4。检查节点=插入节点 开始检查是否满足红黑树。

  - 3.1 检查节点的父节点是祖父节点的左孩子。此时需要判断祖父节点的右孩子(叔叔节点)
  - - 3.1.1 如果祖父节点的右孩子是红色，将父节点和叔叔节点修改为黑色，将祖父节点修改为红色。此时从祖父节点开始已经满足红黑树的条件6，因为更改了祖父节点颜色，需要判断以祖父节点为子节点的数是否满足红黑树。检查节点=祖父节点。

  - - 3.1.2 如果祖父节点的右孩子是黑色。

  - - - 3.1.2.1 如果检查节点为父节点的左孩子，将父节点设为黑色，将祖父节点设为红色，右旋转祖父节点

  - - - 3.1.2.2 如果检查节点为父节点的右孩子，将检查节点设为父节点，左旋旋转检查节点。然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，右旋转祖父节点。

  - 3.2 检查节点的父节点是祖父节点的右孩子。此时需要判断祖父节点的左孩子（叔叔节点）

  - - 3.2.1 如果祖父节点的左孩子是红色，将父节点和叔叔节点修改为黑色，将祖父节点修改为红色。此时从祖父节点开始已经满足红黑树的条件6，因为更改了祖父节点颜色，需要判断以祖父节点为子节点的数是否满足红黑树。检查节点=祖父节点。

  - - 3.2.2 如果祖父节点的左孩子是黑色

  - - - 3.2.2.1 如果检查节点为父节点的右孩子，将父节点设为黑色，将祖父节点设为红色，左旋转祖父节点

  - - - 3.2.2.2 如果检查节点为父节点的左孩子，将检查节点设为父节点，左旋旋转检查节点。然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，右旋转祖父节点。

4. 总结 父节点是黑色，无需修改其他节点，并不会违背红黑树的特点。父节点红色，是共分为两大项6小项

  - 4.1 当前节点的父节点是祖父节点的左子树 关键判断祖父节点右子树的节点的颜色。
  - - 4.1.1 叔叔节点是红色，将父节点、叔叔节点变为黑色，祖父节点变为红色，将检查节点设为祖父节点，继续检查。

  - - 4.1.2 叔叔节点是黑色，判断自己是否是父节点的右子树，如果是右子树，将检查节点设为父节点，以检查节点左旋，该左旋就是为了将检查节点修改为相应父节点的左子树。然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，以右旋检查节点的祖父节点。

  - - 4.1.3 检查节点是父节点的左子树，然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，以右旋检查节点的祖父节点。和4.1.2都是为了以祖父节点为根节点的子数满足红黑树条件6

  - 4.2 当前节点的父节点是祖父节点的右子树，关键判断祖父节点的左子树的节点的颜色

  - - 4.2.1 叔叔节点是红色，将父节点、叔叔节点变为黑色，祖父节点变为红色，将检查节点设为祖父节点，继续检查。

  - - 4.2.2 叔叔节点是黑色，判断自己是否是父节点的左子树，如果是左子树，将检查节点设为父节点，以检查节点右旋，该右旋就是为了将检查节点修改为相应父节点的右子树。然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，以左旋检查节点的祖父节点。

  - - 4.2.3 检查节点是父节点的右子树，然后将检查节点的父节点设为黑色，将检查节点的祖父节点设为红色，以左旋检查节点的祖父节点。和4.1.2都是为了以祖父节点为根节点的子数满足红黑树条件6

#### 旋转

##### 左旋

1. 左旋是将旋转节点的右节点改为当前子树的根节点。
2. 判断旋转节点p是否为空，如果为空直接返回
3. 记录旋转节点p的右节点 r。
4. 将p的右节点设为r的左节点
5. 判断节点r是否有左节点，如果有，将r的左节点的父节点定为p
6. 将r的parent设为原来p的parent。
7. 判断p.parent是否为空，如果为空，p为原来的根节点，将根节点root设为r
8. 判断p是不是p.parent的左节点，如果是将p.parent.left设为r；
9. 其他情况将p.parent.right设为r；
10. 将r的左节点设为p
11. 将p的父节点设为r

##### 右旋

1. 右旋是将选择节点的左节点改为当前子树的根节点
2. 判断旋转节点p是否为空，如果为空直接返回。
3. 记录旋转节点p的左节点 l
4. 将p的左节点设为l的右节点
5. 如果l的右节点不为空，将l的右节点的父节点设为p l.right.parent = p;
6. 将l的parent设为p的parent l.parent = p.parent;
7. 判断p.parent是否为空，如果为空，p为原来的根节点，则将根节点root设为l，
8. 判断p是不是p.parent的右节点，如果是将p.parent.right设为l
9. 其他情况将p.parent.left设为r；
10. 将l的右节点设为p
11. 将p的父节点设为l

## Set

1. 不接受重复元素

### HashSet

1. HashSet是用HashMap实现的。
2. Set的Value值就是它对应的HashMap的Key值，对应的HashMap的值是一个final的Object对象。

### TreeSet

1. TreeSet是用TreeSet实现的。
2. 不接受null的值，是因为需要TreeMap需要比较器进行红黑树排序，null值无法进行比较和排序。

## Queue

1. 队列先进先出

### PriorityQueue：优先级别队列 Since1.5

1. 在插入元素时，使用比较器或者数据自带比较方法进行比较，优先级比较高排在上方。
